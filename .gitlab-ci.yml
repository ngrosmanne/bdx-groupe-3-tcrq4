image: docker:latest
services:
  - name: docker:dind
    alias: docker

stages:          # List of stages for jobs, and their order of execution
  - build
  - scan
  - release-image
  - test-acceptation
  - test-application
  - deploy-staging
  - test-deploy-staging
  - deploy-prod
  - test-deploy-prod
  - monitor

build: # Construction de l'image avec Dockerfile
  stage: build
  script:
    - echo "Construction de l'image avec Dockerfile" 
    - docker build -t imagedevopsapp .
    - rm -f /var/lib/docker/volumes/runner-o3-kzgvp-project-37722816-concurrent-0-cache-c33bcaa1fd2c77edfc3893b41966cea8/_data/ngrosmanne/bdx-groupe-3-tcrq4/imagedevopsapp.tar || echo "Atifacts not found"
    - docker save imagedevopsapp > imagedevopsapp.tar
  artifacts:
    paths:
    - imagedevopsapp.tar   

.scan:   # scan de l'image via docker scan 
  image: centos:7
  stage: scan
  script:
    - yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
    - yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin
    - systemctl start docker
    - docker scan imagedevopsapp
    

.release-image:  # Dépot de l'image sur Dockerhub
  stage: release-image
  script:
    - docker load < imagedevopsapp.tar
    - docker login -u "$DOCKERHUB_USER" -p "$DOCKERHUB_PASSWORD" 
    - docker tag imagedevopsapp:latest bidou974/imagedevopsapp:latest
    - docker push bidou974/imagedevopsapp:latest

.test acceptation: # Controle l'intégrité du conteneur et app   
  stage: test-acceptation
  script:
    - docker rm -f testimagedevopsapp || echo "no run start"
    - docker load < imagedevopsapp.tar
    - docker run -d -p 8081:80 --name testimagedevopsapp imagedevopsapp:latest
    - sleep 5
    - apk --no-cache add curl
    - curl -I 192.168.203.87:8081
    - curl 192.168.203.87:8081 | grep ">Start Bootstrap<"
    - sleep 5
    - docker rm -f testimagedevopsapp

test application:   # Test de l'image
  stage: test-acceptation
  image:
    name: docker.io/aquasec/trivy:latest
    entrypoint: [""]
  variables:
    # No need to clone the repo, we exclusively work on artifacts.  See
    # https://docs.gitlab.com/ee/ci/runners/README.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
    FULL_IMAGE_NAME: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  script:
    - trivy --version
    # cache cleanup is needed when scanning images with the same tags, it does not remove the database
    - time trivy image --clear-cache
    # update vulnerabilities db
    - time trivy --download-db-only --no-progress --cache-dir .trivycache/
    # Builds report and puts it in the default workdir $CI_PROJECT_DIR, so `artifacts:` can take it from there
    - time trivy --exit-code 0 --cache-dir .trivycache/ --no-progress --format template --template "@/contrib/gitlab.tpl"
        --output "$CI_PROJECT_DIR/gl-container-scanning-report.json" "$FULL_IMAGE_NAME"
    # Prints full report
    - time trivy --exit-code 0 --cache-dir .trivycache/ --no-progress "$FULL_IMAGE_NAME"
    # Fail on critical vulnerabilities
    - time trivy --exit-code 1 --cache-dir .trivycache/ --severity CRITICAL --no-progress "$FULL_IMAGE_NAME"
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/ (Container Scanning report is available on GitLab EE Ultimate or GitLab.com Gold)
  artifacts:
    when:                          always
    reports:
      container_scanning:          gl-container-scanning-report.json
  tags:
    - docker-runner

deploy-staging: # Déploiement via runner #16440669 
  stage: deploy-staging
  #image: nginx
  environment:
    name: staging
  only:
    - main
  script:
    - docker rm -f devopsapp || echo "Port 8080 free"
    - docker run -d -p 8080:80 --name devopsapp bidou974/imagedevopsapp

test-deploy-staging: # Test du déploiement staging sur runner 
  stage: test-deploy-staging
  environment:
    name: test-deploy-staging
  only:
    - main
  script:
    - echo "test deploy staging"
    - apk --no-cache add curl
    - curl -I 192.168.203.87:8080

deploy-prod: # Déploiement staging sur WMS 
  stage: deploy-prod
  environment:
    name: prod
    url: https://devopsapp-staging.herokuapp.com
  script:
    - echo "deploy sur prod"
    - apk --no-cache add npm
    - npm install -g heroku
    - heroku container:login
    - heroku container:rm -a devopsapp-staging web || echo "project not exist"
    - heroku create devopsapp-staging || echo "project already exist"
    - heroku container:push -a devopsapp-staging web


.test-deploy-prod: # Test du déploiement staging sur Heroku 
  stage: test-deploy-prod
  script:
    - echo "test deploy prod" 

.monitor:
  stage: monitor 
  script:
    - echo "monitoring prometheus -> grafana"
    
